# (c) Copyright 2016 Hewlett Packard Enterprise Development LP
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed
# under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied. See the License for the
# specific language governing permissions and limitations under the License.


# Managing iLO SSL certificates

# Preface:
# In this example, we'll be checking to see if the SSL certificate is expired or about to expire,
# and if so, replacing it with a new one. That description is probably over-simplified, because
# it's a multi-step process that often involves manual intervention. If you have an automated
# process for signing certificate signing requests (CSRs), great! You'll be able to reep the
# benefits of automation fully. However, even if not, you can still use automation to greatly
# assist in the process.


# Normally, this gem is installed automatically at runtime when the first ilo resource is loaded,
# but since we're requiring the library directly below, we need to make sure it is installed first.
chef_gem 'ilo-sdk' do
  version node['ilo']['ruby_sdk_version']
  compile_time true
end

require 'ilo-sdk' # We need to require this library to create the ILO_SDK::Client below.

ilo1 = ILO_SDK::Client.new(host: 'ilo1.example.com', user: 'Admin', password: 'secret123')
# NOTE: The ILO_SDK::Client class is required here instead of a hash because we'll be calling the
# :get_csr method on it.

# Get the current SSL Certificate and check to see if expires within 7 days
# We'll mark certs that are expired or expiring in < 7 days as invalid
expiration = ilo1.get_certificate.not_after.to_datetime
valid = expiration > (DateTime.now + 7)

# Now we'll generate a CSR if the cert is not valid
# Note that this process takes about 10 minutes, and we won't actually wait until it completes.
ilo_https_cert 'generate CSR' do
  ilo ilo1
  country 'US'
  state 'Texas'
  city 'Houston'
  orgName 'Example Company'
  orgUnit 'MyOrg'
  commonName 'ilo1.example.com'
  action :generate_csr
  not_if { valid || ilo1.get_csr.to_s.include?('BEGIN CERTIFICATE REQUEST') } # Only generate if the
  # cert is expiring soon and the CSR has not already been generated
end

# Create the directory where we want to place the csr and cert files (~/certs)
directory "#{ENV['HOME']}/certs" do
  mode '0750'
end

# When the CSR is generated, we'll dump it to a file. We can check if it's generated by using the
# iLO client object to query the CSR enpoint and check if it contains a CSR (see the "not_if")
# Since the generation process takes ~10 min, running the chef-client periodically on an interval
# allows this resource to pick up where the generate resource left off and complete another step
# of the process.
ilo_https_cert 'dump ilo1 CSR to file' do
  ilo ilo1
  file_path "#{ENV['HOME']}/certs/ilo1.csr"
  action :dump_csr
  not_if { valid || !ilo1.get_csr.to_s.include?('BEGIN CERTIFICATE REQUEST') } # Don't dump the CSR
  # file if the cert is still valid or the csr is not finished being generated
end

# -------------------BEGIN CERT SIGN SECTION-------------------
# Here you'll need to have a step that submits the CSR to a certificate authority (or self-signs it)
# and gets back the signed certificate. It will look something like:
# -----BEGIN CERTIFICATE-----
# lines_of_secret_text
# -----END CERTIFICATE-----
# Again, if you have an automated process, that's great, but you don't have to. You can still perform
# the signing process manually, and just drop the certificate at a defined path so that the import
# resource can find it.

# We'll generate our own CA keys and use them to sign the CSR.
# REPLACE THIS SECTION WITH YOUR OWN SIGNING PROCESS
certs_dir = "#{ENV['HOME']}/certs"
ca_pass = "#{certs_dir}/ca.passphrase"
ca_key = "#{certs_dir}/ca.key"
ilo1_cert = "#{certs_dir}/ilo1.cert"
file ca_pass do
  content((0...48).map { (65 + rand(26)).chr }.join) # Randomly generated string
  sensitive true
  action :create_if_missing
end

execute 'create private CA key' do
  command "openssl genrsa -des3 -out #{ca_key} -passout file:#{ca_pass} 2048"
  not_if { File.exist?(ca_key) }
end

execute 'write RSA key' do
  command "openssl rsa -in #{ca_key} -passin file:#{ca_pass} -out #{ca_key}"
  only_if { File.readlines(ca_key).grep(/DEK-Info/).any? }
end

execute 'sign csr' do
  command "openssl x509 -req -days 365 -in #{certs_dir}/ilo1.csr -signkey #{ca_key} -out #{ilo1_cert}"
  not_if { File.exist?(ilo1_cert) }
end
# --------------------END CERT SIGN SECTION--------------------


# After the cert has been created, import it. For this example, we're assuming we've signed the CSR
# and output the certificate to a file at ~/certs/ilo1.cert
ilo_https_cert 'import certificate' do
  ilo ilo1
  file_path "#{ENV['HOME']}/certs/ilo1.cert"
  action :import
  not_if { valid || !File.exist?(ilo1_cert) } # Only if the cert file exists and the cert is not valid
  notifies :resetilo, 'ilo_power[reset_ilo1]', :delayed
  notifies :delete, 'file[delete ilo1.csr]'  # Optional: Clean-up csr file
  notifies :delete, 'file[delete ilo1_cert]' # Optional: Clean-up cert file
end


# The next few resources have the :nothing action, because we only want to take an action if notified
# to do so. After the cert is imported, we need to restart the iLO, and we may want to clean-up the
# csr and cert files as well.
ilo_power 'reset_ilo1' do
  ilos [ilo1]
  action :nothing # Restart the iLO only if notified to do so (after importing the cert)
end

file 'delete ilo1.csr' do
  path "#{ENV['HOME']}/certs/ilo1.csr"
  action :nothing # Only delete if notified to do so (after importing the cert)
end

file 'delete ilo1_cert' do
  path ilo1_cert
  action :nothing # Only delete if notified to do so (after importing the cert)
end
